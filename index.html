<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Player</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>

<body>
    <div class="container">
        <div class="left-section">
            <div class="album-cover-container">
                <img id="album-cover" src="default-cover.jpg" alt="Album Cover">
            </div>
            <div id="now-playing"></div>
            <div class="progress-container">
                <input type="range" id="progress-bar" min="0" max="100" value="0">
                <div id="time-display">
                    <span id="current-time">0:00</span>
                    <span id="duration">0:00</span>
                </div>
            </div>
            <div class="player-controls">
                <button id="prev"><i class="fas fa-backward"></i></button>
                <button id="play-pause"><i class="fas fa-play"></i></button>
                <button id="next"><i class="fas fa-forward"></i></button>
            </div>
            <audio id="audio-player"></audio>
        </div>
        <div class="right-section-container" id="right-section-container">
            <button id="toggle-list" class="toggle-button">▶</button>
            <div class="right-section" id="right-section">
                <div id="playlist"></div>
            </div>
        </div>
    </div>
    <script>
        const { ipcRenderer } = require('electron');

        let currentTrackIndex = 0;
        let playlist = [];
        let audio = document.getElementById('audio-player');

        // 新增：音频加载控制
        let isAudioLoading = false;

        // 保存播放状态到存储
        function savePlaybackState() {
            ipcRenderer.send('save-playback-state', {
                index: currentTrackIndex,
                time: audio.currentTime
            });
        }

        // 渲染播放列表
        function renderPlaylist() {
            const list = document.getElementById('playlist');
            list.innerHTML = playlist.map((track, index) => `
                <div class="track ${index === currentTrackIndex ? 'playing' : ''}" data-index="${index}">
                    <span class="title">${track.title}</span>
                    <span class="artist">${track.artist}</span>
                    <span class="duration">${formatDuration(track.duration)}</span>
                </div>
            `).join('');

            document.querySelectorAll('.track').forEach(item => {
                item.addEventListener('click', () => {
                    currentTrackIndex = parseInt(item.dataset.index);
                    playTrack(playlist[currentTrackIndex]);
                });
            });
        }

        // 修改后的播放控制函数
        async function playTrack(track) {
            // 停止当前播放的音频
            if (!audio.paused) {
                audio.pause();
                audio.removeEventListener('timeupdate', updateProgress);
                audio.removeEventListener('ended', handleTrackEnd);
            }

            isAudioLoading = true;

            // 立即重置UI状态
            document.getElementById('progress-bar').value = 0;
            document.getElementById('current-time').textContent = '0:00';
            document.getElementById('duration').textContent = '0:00';

            const coverImg = document.getElementById('album-cover');
            const playPauseIcon = document.getElementById('play-pause').querySelector('i');

            // 创建新的音频实例
            const newAudio = new Audio();
            newAudio.preload = 'metadata';

            // 加载元数据
            await new Promise((resolve) => {
                newAudio.src = track.path;
                newAudio.addEventListener('loadedmetadata', () => {
                    // 更新持续时间显示
                    document.getElementById('duration').textContent = formatDuration(newAudio.duration);
                    resolve();
                }, { once: true });
            });

            // 替换原有音频元素
            const oldAudio = audio;
            audio = newAudio;
            oldAudio.remove();

            // 初始化播放状态
            audio.currentTime = 0;
            audio.play();

            // 更新播放控制状态
            playPauseIcon.classList.remove('fa-play');
            playPauseIcon.classList.add('fa-pause');

            // 显示专辑封面
            if (track.cover) {
                try {
                    const byteCharacters = atob(track.cover.data);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: track.cover.format || 'image/jpeg' });
                    coverImg.src = URL.createObjectURL(blob);
                } catch (error) {
                    coverImg.src = 'default-cover.jpg';
                }
            } else {
                coverImg.src = 'default-cover.jpg';
            }

            document.getElementById('now-playing').textContent = `正在播放：${track.title} - ${track.artist}`;
            document.querySelector('.playing')?.classList.remove('playing');
            document.querySelector(`[data-index="${currentTrackIndex}"]`).classList.add('playing');

            // 开始旋转封面
            coverImg.classList.add('rotate');

            // 滚动当前歌曲到中央
            const currentTrackElement = document.querySelector(`[data-index="${currentTrackIndex}"]`);
            currentTrackElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // 保存播放状态
            savePlaybackState();

            // 绑定新音频事件
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('ended', handleTrackEnd);

            isAudioLoading = false;
        }

        // 新增：加载曲目信息但不播放
        async function loadTrack(track) {
            // 停止当前播放的音频
            if (!audio.paused) {
                audio.pause();
                audio.removeEventListener('timeupdate', updateProgress);
                audio.removeEventListener('ended', handleTrackEnd);
            }

            isAudioLoading = true;

            // 立即重置UI状态
            document.getElementById('progress-bar').value = 0;
            document.getElementById('current-time').textContent = '0:00';
            document.getElementById('duration').textContent = '0:00';

            const coverImg = document.getElementById('album-cover');

            // 创建新的音频实例
            const newAudio = new Audio();
            newAudio.preload = 'metadata';

            // 加载元数据
            await new Promise((resolve) => {
                newAudio.src = track.path;
                newAudio.addEventListener('loadedmetadata', () => {
                    // 更新持续时间显示
                    document.getElementById('duration').textContent = formatDuration(newAudio.duration);
                    resolve();
                }, { once: true });
            });

            // 替换原有音频元素
            const oldAudio = audio;
            audio = newAudio;
            oldAudio.remove();

            // 显示专辑封面
            if (track.cover) {
                try {
                    const byteCharacters = atob(track.cover.data);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: track.cover.format || 'image/jpeg' });
                    coverImg.src = URL.createObjectURL(blob);
                } catch (error) {
                    coverImg.src = 'default-cover.jpg';
                }
            } else {
                coverImg.src = 'default-cover.jpg';
            }

            document.getElementById('now-playing').textContent = `正在播放：${track.title} - ${track.artist}`;
            document.querySelector('.playing')?.classList.remove('playing');
            document.querySelector(`[data-index="${currentTrackIndex}"]`).classList.add('playing');

            // 确保暂停状态
            audio.pause();
            document.getElementById('play-pause').querySelector('i').classList.add('fa-play');
            document.getElementById('play-pause').querySelector('i').classList.remove('fa-pause');
            coverImg.classList.remove('rotate');

            isAudioLoading = false;
        }

        // 修改后的进度更新函数
        function updateProgress() {
            if (isAudioLoading) return;

            const progress = (audio.currentTime / audio.duration) * 100;
            document.getElementById('progress-bar').value = progress;
            document.getElementById('current-time').textContent = formatDuration(audio.currentTime);
        }

        // 播放结束自动下一首
        function handleTrackEnd() {
            currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
            playTrack(playlist[currentTrackIndex]);
        }

        document.getElementById('play-pause').addEventListener('click', () => {
            const playPauseIcon = document.getElementById('play-pause').querySelector('i');
            const coverImg = document.getElementById('album-cover');

            if (audio.paused) {
                audio.play();
                playPauseIcon.classList.remove('fa-play');
                playPauseIcon.classList.add('fa-pause');
                coverImg.classList.add('rotate'); // 恢复旋转
            } else {
                audio.pause();
                playPauseIcon.classList.remove('fa-pause');
                playPauseIcon.classList.add('fa-play');
                coverImg.classList.remove('rotate'); // 停止旋转
            }
        });

        document.getElementById('prev').addEventListener('click', () => {
            currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
            playTrack(playlist[currentTrackIndex]);
        });

        document.getElementById('next').addEventListener('click', () => {
            currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
            playTrack(playlist[currentTrackIndex]);
        });

        document.getElementById('toggle-list').addEventListener('click', () => {
            const container = document.querySelector('.container');
            const rightContainer = document.getElementById('right-section-container');
            rightContainer.classList.toggle('is-collapsed');
            container.classList.toggle('is-collapsed');
        });

        // 时间格式化
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 初始化加载播放列表和状态
        (async () => {
            const { playlist: storedPlaylist, lastPlayedIndex, lastPlayedTime } = await ipcRenderer.invoke('get-playlist');
            playlist = storedPlaylist;

            // 处理索引越界
            currentTrackIndex = lastPlayedIndex;
            if (currentTrackIndex >= playlist.length && playlist.length > 0) {
                currentTrackIndex = 0;
            }

            renderPlaylist();

            if (playlist.length > 0) {
                const track = playlist[currentTrackIndex];
                await loadTrack(track);

                audio.currentTime = lastPlayedTime;

                // 更新进度显示
                document.getElementById('current-time').textContent = formatDuration(lastPlayedTime);
                document.getElementById('progress-bar').value = (lastPlayedTime / audio.duration) * 100 || 0;
            }
        })();

        // 窗口关闭前保存状态
        window.addEventListener('beforeunload', () => {
            savePlaybackState();
        });

        // 监听播放列表更新
        ipcRenderer.on('update-playlist', (event, newTracks) => {
            playlist = newTracks;
            renderPlaylist();
        });

        // 更新进度条
        const progressBar = document.getElementById('progress-bar');
        progressBar.addEventListener('input', () => {
            const seekTime = (progressBar.value / 100) * audio.duration;
            audio.currentTime = seekTime;
        });
    </script>
</body>

</html>